<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>API å‘½åè§„èŒƒåŒ–å·¥å…· - å¢å¼ºç‰ˆ</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/build/kuromoji.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px; background: #f0f2f5; color: #333; }
        .container { max-width: 900px; margin: 0 auto; display: grid; grid-template-columns: 1fr 300px; gap: 20px; }
        .main-panel, .side-panel { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        h2, h3 { margin-top: 0; color: #1a73e8; }
        textarea { width: 100%; height: 80px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box; font-size: 16px; margin-bottom: 15px; }
        .result-item { background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #1a73e8; position: relative; }
        .result-label { font-size: 12px; color: #666; margin-bottom: 4px; }
        .result-value { font-family: 'Courier New', Courier, monospace; font-weight: bold; color: #d93025; font-size: 1.1em; }
        
        /* ä¾§è¾¹æ è¯å…¸æ ·å¼ */
        .dict-list { max-height: 400px; overflow-y: auto; border-top: 1px solid #eee; padding-top: 10px; }
        .dict-item { display: flex; justify-content: space-between; font-size: 13px; padding: 4px 0; border-bottom: 1px dashed #eee; }
        .add-dict { display: flex; gap: 5px; margin-bottom: 15px; }
        .add-dict input { flex: 1; padding: 5px; border: 1px solid #ddd; border-radius: 4px; }
        .btn { cursor: pointer; background: #1a73e8; color: white; border: none; padding: 5px 10px; border-radius: 4px; }
        .btn-del { background: #ff4d4f; padding: 2px 6px; font-size: 10px; }
        .status { font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div id="app" class="container">
        <div class="main-panel">
            <h2>ğŸš€ API å‘½åè½¬æ¢</h2>
            <div class="status" v-if="!isReady">â³ æ­£åœ¨åŠ è½½åˆ†è¯å­—å…¸...</div>
            
            <textarea v-model="input" :disabled="!isReady" placeholder="è¾“å…¥æ—¥è¯­ï¼Œä¾‹å¦‚ï¼šé¡§å®¢æƒ…å ±ç™»éŒ²..."></textarea>
            
            <div v-if="isReady">
                <div class="result-item">
                    <div class="result-label">å°é©¼å³° (camelCase)</div>
                    <div class="result-value">{{ camelResult }}</div>
                </div>
                <div class="result-item">
                    <div class="result-label">ä¸‹åˆ’çº¿ (snake_case)</div>
                    <div class="result-value">{{ snakeResult }}</div>
                </div>
                <div class="result-item">
                    <div class="result-label">åˆ†è¯è¯¦æƒ… (è°ƒè¯•)</div>
                    <div style="font-size: 12px; color: #999;">{{ tokensDetail }}</div>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <h3>ğŸ“– æ‰‹åŠ¨è¯å…¸</h3>
            <div class="add-dict">
                <input v-model="newJa" placeholder="æ—¥è¯­">
                <input v-model="newEn" placeholder="è‹±æ–‡">
                <button class="btn" @click="addEntry">æ·»åŠ </button>
            </div>
            
            <div class="dict-list">
                <div v-for="(en, ja) in customDict" :key="ja" class="dict-item">
                    <span><b>{{ ja }}</b> â†’ {{ en }}</span>
                    <button class="btn btn-del" @click="removeEntry(ja)">åˆ é™¤</button>
                </div>
            </div>
            <p style="font-size: 11px; color: #999; margin-top: 10px;">* æ•°æ®ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­</p>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, watch, onMounted } = Vue;

        // å†…ç½®æ ‡å‡†è¯å…¸ (æ— æ³•åˆ é™¤çš„åŸºç¡€è¯æ±‡)
        const BASE_DICT = {
            "ä½œæˆ": "create", "æ–°è¦": "create", "å‰Šé™¤": "delete", "æ¶ˆå»": "delete",
            "æ›´æ–°": "update", "ç·¨é›†": "edit", "å–å¾—": "get", "ä¸€è¦§": "list",
            "è©³ç´°": "detail", "é¡§å®¢": "customer", "æƒ…å ±": "info", "è¨­å®š": "setting"
        };

        createApp({
            setup() {
                const input = ref('');
                const isReady = ref(false);
                const tokenizer = ref(null);
                const newJa = ref('');
                const newEn = ref('');
                
                // ä» LocalStorage åŠ è½½ç”¨æˆ·è‡ªå®šä¹‰è¯å…¸
                const customDict = ref(JSON.parse(localStorage.getItem('api_custom_dict') || '{}'));

                // åˆå§‹åŒ–åˆ†è¯å™¨
                onMounted(() => {
                    kuromoji.builder({ dicPath: "https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict/" }).build((err, _tokenizer) => {
                        if (err) return alert("å­—å…¸åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•");
                        tokenizer.value = _tokenizer;
                        isReady.value = true;
                    });
                });

                // æ·»åŠ è‡ªå®šä¹‰è¯æ¡
                const addEntry = () => {
                    if (newJa.value && newEn.value) {
                        customDict.value[newJa.value.trim()] = newEn.value.trim();
                        newJa.value = '';
                        newEn.value = '';
                        saveDict();
                    }
                };

                // åˆ é™¤è‡ªå®šä¹‰è¯æ¡
                const removeEntry = (key) => {
                    delete customDict.value[key];
                    saveDict();
                };

                const saveDict = () => {
                    localStorage.setItem('api_custom_dict', JSON.stringify(customDict.value));
                };

                // æ··åˆè¯å…¸æŸ¥è¯¢
                const translate = (word) => {
                    // ä¼˜å…ˆçº§ï¼šè‡ªå®šä¹‰è¯å…¸ > å†…ç½®è¯å…¸ > åŸè¯
                    return customDict.value[word] || BASE_DICT[word] || word;
                };

                // åˆ†è¯ä¸è½¬æ¢é€»è¾‘
                const processedWords = computed(() => {
                    if (!input.value || !tokenizer.value) return [];
                    const tokens = tokenizer.value.tokenize(input.value);
                    return tokens.map(t => translate(t.surface_form));
                });

                const tokensDetail = computed(() => {
                    if (!tokenizer.value || !input.value) return '';
                    return tokenizer.value.tokenize(input.value).map(t => t.surface_form).join(' | ');
                });

                const camelResult = computed(() => {
                    const ws = processedWords.value;
                    return ws.map((w, i) => i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join('');
                });

                const snakeResult = computed(() => {
                    return processedWords.value.join('_').toLowerCase();
                });

                return { 
                    input, isReady, camelResult, snakeResult, 
                    customDict, newJa, newEn, addEntry, removeEntry, tokensDetail 
                };
            }
        }).mount('#app');
    </script>
</body>
</html>